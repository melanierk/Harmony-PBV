//===- PtBlockProfiling.cpp - Insert counters for pthread profiling -------===//
//
// kt2384 (Kui Tang)
//
//===----------------------------------------------------------------------===//
//
// This pass instruments the specific program with thread count histograms
//
//===----------------------------------------------------------------------===//
#define DEBUG_TYPE "insert-ptblock-profiling"

// this version has NO hoisting!

#include "ProfilingUtils.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Instruction.h"
#include "llvm/Instructions.h"
#include "llvm/InstrTypes.h"
#include "llvm/Module.h"
#include "llvm/Pass.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
#include "llvm/Transforms/Instrumentation.h"
#include "llvm/ADT/Statistic.h"
#include <set>
#include <sstream>
#include <cstring>
#include <stdint.h>
using namespace llvm;

static cl::opt<bool>
PROF_EVC("DPROF_EVC", cl::init(false), cl::Hidden,
	 cl::desc("Add instrumentation for event counting"));

static cl::opt<bool>
PROF_ATC("DPROF_ATC", cl::init(false), cl::Hidden,
	 cl::desc("Add instrumentation for active thread counting"));

static cl::opt<bool>
PROF_ATH("DPROF_ATH", cl::init(false), cl::Hidden,
	 cl::desc("Add instrumentation for active thread histograms"));

static cl::opt<bool>
PROF_ATIME("DPROF_ATIME", cl::init(false), cl::Hidden,
	   cl::desc("Add instrumentation for active thread count timeline"));

static cl::opt<bool>
PROF_WTC("DPROF_WTC", cl::init(false), cl::Hidden,
	 cl::desc("Add instrumentation for working thread counting"));

static cl::opt<bool>
PROF_WTH("DPROF_WTH", cl::init(false), cl::Hidden,
	 cl::desc("Add instrumentation for working thread histograms"));

static cl::opt<bool>
PROF_WTIME("DPROF_WTIME", cl::init(false), cl::Hidden,
	   cl::desc("Add instrumentation for working thread count timeline"));

static cl::opt<std::string>
special_case("special_case", cl::init(""), cl::Hidden,
     cl::desc("Run special case instructions for given application"));

STATISTIC(NumBlocks, "The # of blocks instrumented.");
STATISTIC(NumThreadEntries, "The # of thread entries points instrumented.");

static int ntaboo = 5;
static StringRef taboo[] = { "_init", "frame_dummy", "__do_global_ctors_aux", "__cxx_global_var_init", "_GLOBAL__I" };

static int ntaboo_facesim = 5;
static StringRef taboo_facesim[] = { "Resize_Array", "Append_Element", "ARG_DATA", "PARSE_ARGS", "PARTICLE_ATTRIBUTE_COLLECTION_MAP" };

static bool isTaboo(Function *F) {
  for (int i = 0; i < ntaboo; i++) {
    if (F->getName().find(taboo[i]) != StringRef::npos) {
      DEBUG(errs() << "Found taboo function " << F->getName() << "\n");
      return true;
    }
  }
  for (int i = 0; i< ntaboo_facesim; i++) {
    if (F->getName().find(taboo_facesim[i]) != StringRef::npos) {
      errs() << "SPECIAL CASE FACESIM Found taboo function " << F->getName() << "\n";
      return true;
    }
  }

  return false;
}

static int nferret_start_routines = 6;
static StringRef ferret_start_routines[] = { "t_load", "t_seg", "t_extract", "t_vec", "t_rank", "t_out" };

static bool isFerretStartRoutine(Function *F) {
  for (int i = 0; i < nferret_start_routines; i++) {
    if (F->getName() == ferret_start_routines[i]) {
      errs() << "SPECIAL CASE FERRET FOUND START ROUTINE " << F->getName() << "\n";
      return true;
    }
  }
  return false;
}

 
namespace {
  class PtBlockProfiler : public ModulePass {
    bool runOnModule(Module &M);
  public:
    static char ID; // Pass identification, replacement for typeid
    PtBlockProfiler() : ModulePass(ID) {
      //initializePtBlockProfilerPass(*PassRegistry::getPassRegistry());
    }

    virtual const char *getPassName() const {
      return "Pthread Block Profiler (kt2384)";
    }
  };
}

char PtBlockProfiler::ID = 0;
// macro--no semicolon

INITIALIZE_PASS(PtBlockProfiler, "insert-ptblock-profiling", "Insert instrumentation for pthread block profiling", false, false)

ModulePass *llvm::createPtBlockProfilerPass() { return new PtBlockProfiler(); }

// Recursively check V for a Function. 
// If V is a Function, cast it and return.
// Else if V is a User (a Value that takes operands), recurse on its 0th
// operand.
// Otherwise, die.
static Function *FindStartRoutineFunction(Value *V) {
  if (Function *F = dyn_cast<Function>(V)) {
    // First try casting the value to a Function.
    DEBUG(errs() << F->getName() << " was a start routine.\n");
    return F;
  } else if (User *U = dyn_cast<User>(V)) {
    // The operand to pthread_create could be an instruction embedding a
    // Function, such as a bitcast. In that case, such instruction is a
    // subclass of User, use has the getOperand() method. We get the
    // operand and attempt to cast to a function.
    return FindStartRoutineFunction(U->getOperand(0));
  } 
  errs() << "PtBlockProfiling ERROR: V was " << *V << " which is not a Function or User\n";
  return 0;
}

static Function *StartRoutineFromPtCreate(Module &M, CallInst *call) {
  // Returns the function pointed to by start_routine for the call, otherwise
  // null if call is not a pthread_create call.
  Function *ptCreateF = call->getCalledFunction();
  // BUGFIX (9/30): call->getCalledFunction() may return NULL, so catch it.
  // if this doesn't work try to first find pthread_create call
  // also they could have renamed what is pthread_create. So change it.
  if (!ptCreateF) { return 0; }

  if (ptCreateF->getName() == "pthread_create") { 
    // The third parameter to pthread_create is the name of the function which
    // will run in a new thread.
    return FindStartRoutineFunction(call->getArgOperand(2));
  }
  // 11/8: added support for g_thread_create (however, you must instrument the
  // gthread library, as actions are not interposed by the header).
  if (ptCreateF->getName() == "g_thread_create" ||
      ptCreateF->getName() == "g_thread_create_full") {
    // The first parameter of g_thread_create and g_thread_create_full 
    // contains th e start routine function
    return FindStartRoutineFunction(call->getArgOperand(0));
  }
  
  // otherwise, this was not a start routine
  return 0;
}

inline static Instruction *getFirstInst(Function *F) {
  Instruction *FirstNonPHI = F->getEntryBlock().getFirstNonPHI();
  assert(FirstNonPHI != 0);
  return FirstNonPHI;
}

static void insertModuleInitCall(Function *MainFn, std::vector<BasicBlock*> &Blocks, Module &M) {
  LLVMContext &Context = M.getContext();


  // ---------------------------------------
  // PART I: CREATE THE FUNCTION DECLARATION
  // ---------------------------------------
  // void PROF_IN_init_module(uint32_t nbasic_blocks, char *names, char *outpath);
  const Type *CharTy = Type::getInt8Ty(Context);
  PointerType *PtrCharTy  = PointerType::get(CharTy, 0);
  std::vector<const Type*> ArgTypes(3);
  ArgTypes[0] = Type::getInt32Ty(Context);
  ArgTypes[1] = PtrCharTy;
  ArgTypes[2] = PtrCharTy;
  FunctionType *ModuleInitProto = FunctionType::get(Type::getVoidTy(Context),
                                                    ArgTypes,
                                                    false);
  DEBUG(errs() << "insertModuleInitCall: PROF_IN_init_module prototype is " <<
                  *ModuleInitProto << "\n");

  Constant *ModuleInitFn = M.getOrInsertFunction("PROF_IN_init_module",
                                                 ModuleInitProto);
  DEBUG(errs() << "insertModuleInitCall: PROF_IN_init_module declaration is " <<
                  *ModuleInitFn << "\n");

  // ------------------------------------
  // PART II: CREATE THE GLOBAL VARIABLES
  // ------------------------------------

  std::stringstream SSNames;
  // TODO: More STL-idiomatic way to insert commas?
  for (std::vector<BasicBlock*>::iterator i = Blocks.begin();
       i != Blocks.end();
       ++i) {
    SSNames << (**i).getParent()->getName().str() << ":" << (**i).getName().str() << ",";
  }

  // TODO: Change
  std::string Names = SSNames.str();
  std::string Outpath("out.csv");

  Constant* const_array_Names   = ConstantArray::get(M.getContext(), Names, /*AddNull=*/true);
  Constant* const_array_Outpath = ConstantArray::get(M.getContext(), Outpath, true);
  //DEBUG(errs() << "insertModuleInitCall: const_array_Names = " << *const_array_Names << "\n");
  DEBUG(errs() << "insertModuleInitCall: const_array_Outpath = " << *const_array_Outpath << "\n");
  ArrayType *NamesArrTy   = ArrayType::get(CharTy, Names.size() + 1);
  ArrayType *OutpathArrTy = ArrayType::get(CharTy, Outpath.size() + 1);
   
  GlobalVariable* gvar_array__PROF_names = new GlobalVariable(/*Module=*/M, 
  /*Type=*/NamesArrTy,
  /*isConstant=*/false,
  /*Linkage=*/GlobalValue::InternalLinkage,
  /*Initializer=*/const_array_Names,
  /*Name=*/"_PROF_names");
  gvar_array__PROF_names->setAlignment(1);
  DEBUG(errs() << "insertModuleInitCall: gvar_array__PROF_outpath = " <<
        *gvar_array__PROF_names << "\n");
  
  GlobalVariable* gvar_array__PROF_outpath = new GlobalVariable(/*Module=*/M, 
  /*Type=*/OutpathArrTy,
  /*isConstant=*/false,
  /*Linkage=*/GlobalValue::InternalLinkage,
  /*Initializer=*/const_array_Outpath,
  /*Name=*/"_PROF_outpath");
  gvar_array__PROF_outpath->setAlignment(1);
  DEBUG(errs() << "insertModuleInitCall: gvar_array__PROF_names = " <<
        *gvar_array__PROF_outpath << "\n");
  
  // Constant Definitions
  gvar_array__PROF_names->setInitializer(const_array_Names);
  gvar_array__PROF_outpath->setInitializer(const_array_Outpath);

  // -------------------------------------
  // PART III: CREATE THE CALL INSTRUCTION
  // -------------------------------------
  // Read http://llvm.org/docs/GetElementPtr.html 
  std::vector<Constant*> GEPIndices(2);
  Constant *ZeroInt = ConstantInt::get(Context, APInt(32, 0));
  GEPIndices[0] = ZeroInt;
  GEPIndices[1] = ZeroInt;
  Constant *GEPNames = ConstantExpr::getGetElementPtr(gvar_array__PROF_names,
                                                      &GEPIndices[0],
                                                      GEPIndices.size(),
                                                      true);
  Constant *GEPOutpath = ConstantExpr::getGetElementPtr(gvar_array__PROF_outpath,
                                                        &GEPIndices[0],
                                                        GEPIndices.size(),
                                                        true);
  
  std::vector<Value*> Args(3);
  Args[0] = ConstantInt::get(Context, APInt(32, Blocks.size()));
  Args[1] = GEPNames;
  Args[2] = GEPOutpath;
  CallInst *ModuleInitCall = CallInst::Create(ModuleInitFn,
                                              Args.begin(),
                                              Args.end(),
                                              "",
                                              getFirstInst(MainFn));
  DEBUG(errs() << "insertModuleInitCall: inserted CallInst " << *ModuleInitCall << "\n");

  // This part's confusing--literalizing the string. Do it later.
  // Add the string constant names to the module
//  llvm::ConstantArray NamesConstArr = //

  // The Module initialization call must be the first instruction in main.
}

static FunctionType *ThreadInitProto;
static void initThreadInitProto(LLVMContext &Context) {
  // void PROF_IN_init_thread();
  ThreadInitProto = FunctionType::get(Type::getVoidTy(Context),
                                      false);
}

static void insertThreadInitCall(Function *StartRoutine, Module &M) {
  DEBUG(errs() << "insertThreadInitCall with StartRoutine = " << StartRoutine->getName() << "\n");
  Constant *ThreadInitFn = M.getOrInsertFunction("PROF_IN_init_thread",
                                                 ThreadInitProto);

  Instruction *FirstInst = getFirstInst(StartRoutine);  
  // Insert before FirstInst
  CallInst *ThreadInitCall = CallInst::Create(ThreadInitFn,
                                              "",
                                              FirstInst);
  DEBUG(errs() << "insertThreadInitCall inserted " << *ThreadInitCall << "\n");
}

static FunctionType *SampleProto;
static void initSampleProto(LLVMContext &Context) {
  // TODO: Factor the function type stuff
  std::vector<const Type*> ArgTypes(1);
  ArgTypes[0] = Type::getInt32Ty(Context);
  // void PROF_IN_sample(uint32_t bb_id);
  SampleProto = FunctionType::get(Type::getVoidTy(Context),
                                                  ArgTypes,
                                                  false);
}

static void insertSampleCall(BasicBlock *Block, uint32_t bb_id, Module &M) {
  DEBUG(errs() << "insertSampleCall with Block = " << Block->getName() << " and bb_id = " << bb_id << "\n");

  Constant *SampleFn = M.getOrInsertFunction("PROF_IN_sample",
                                             SampleProto);
  std::vector<Value*> Args(1);
  Args[0] = ConstantInt::get(Type::getInt32Ty(M.getContext()), bb_id);
  // TODO: Which signature is this???
  // Insert sampling at end of block.
  CallInst *SampleCall = CallInst::Create(SampleFn,
                                          Args.begin(),
                                          Args.end(),
                                          "",
                                          Block->getTerminator());
}

static FunctionType *FunctionInitProto;
static void initFunctionInitProto(LLVMContext &Context) {
  // void PROF_IN_init_thread();
  FunctionInitProto = FunctionType::get(Type::getVoidTy(Context),
                                      false);
}

bool PtBlockProfiler::runOnModule(Module &M) {
  // Find our Basic Blocks and pthread_create calls
  std::vector<BasicBlock*> Blocks;
  std::set<Function*> PtStartRoutines;
  Function *TmpStartRoutine;

  // flags defined to match ptprofile.h wrapper
  bool PROF_HIST = (PROF_ATH || PROF_WTH);
  bool PROF_COUNT = (PROF_ATC || PROF_WTC);
  bool PROF_TIME = (PROF_ATIME || PROF_WTIME);
  bool PROF_OUTFILE = (PROF_HIST || PROF_TIME || PROF_EVC);
  bool PROF_ANY = (PROF_COUNT || PROF_OUTFILE);

  // Get list of blocks *before* any instrumentation inserted and add names
  int nDecls = 0;
  int nTaboos = 0;
  int nFuncs = 0;
  for (Module::iterator F = M.begin(), E = M.end(); F != E; ++F) {
    errs() << "FUNCTION: " << F->getName().str() << "\n";
    nFuncs++;
    if (F->isDeclaration()) { continue; nDecls++; }
    if (isTaboo(F)) { continue; nTaboos++; }
    for (Function::iterator BB = F->begin(), E = F->end(); BB != E; ++BB) {
      Blocks.push_back(BB);
    }
  }
  errs() << "MARTHA: " << Blocks.size() << " basic blocks\n";
  //  errs() << "MARTHA: nFuncs=" << nFuncs << " \n";
  //  errs() << "MARTHA: nDecls=" << nDecls << " \n";
  //  errs() << "MARTHA: nTaboos=" << nTaboos << " \n";

  // Prepend our tag to each block name
  for (unsigned i = 0; i < Blocks.size(); ++i) {
    BasicBlock* BB = Blocks[i];
    std::stringstream nn;
    //    nn << "bbl" << i << "_sz" << BB->size() << BB->getName().str();
    nn << "bbl" << i;
    BB->setName(nn.str());
    //    errs() << "BB-SUMM: Basic block " << BB->getName() << " (parent=" << BB->getParent()->getName().str() << "):\n";
    //    errs() << "BB-BODY: ";
    //    for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E; ++I) {
    //      errs() << I->getOpcodeName() << " ";
    //    }
    //    errs() << "\n";
  }

  // Print Module for debugging
  //  errs() << "================================================================================\n";
  //  M.dump();
  //  errs() << "================================================================================\n";

  if (PROF_ANY) { initFunctionInitProto(M.getContext()); }
  for (Module::iterator F = M.begin(), E = M.end(); F != E; ++F) {
    if (F->isDeclaration()) continue;
    if (isTaboo(F)) continue;

    if (PROF_ANY && special_case == "ferret" && isFerretStartRoutine(F)) {
      PtStartRoutines.insert(F);
    }

    for (Function::iterator BB = F->begin(), E = F->end(); BB != E; ++BB) {
      // MARTHA: already collected blocks above
      //      Blocks.push_back(BB);
  
      // find the pthread_create calls
      if (PROF_ANY) {
        for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E; ++I) {
          if (CallInst *CI = dyn_cast<CallInst>(I)) {
            TmpStartRoutine = StartRoutineFromPtCreate(M, CI);
            if (TmpStartRoutine) {
              PtStartRoutines.insert(TmpStartRoutine);
            }
          }
        } // for BasicBlock::iterator I
      } // if (PROF_ANY)
    } // for Function::iterator BB
  } // for Module::iterator F
  NumBlocks = Blocks.size();
  NumThreadEntries = PtStartRoutines.size();

  // Initialize all start routines, except main, which takes care of its thread
  // initialization within the ModuleInitCall.
  if (PROF_ANY) { initThreadInitProto(M.getContext()); }
  for (std::set<Function*>::iterator i = PtStartRoutines.begin();
       i != PtStartRoutines.end();
       ++i) {
    if (PROF_HIST || PROF_EVC || PROF_TIME) {
      insertThreadInitCall(*i, M);
      DEBUG(errs() << "Start routine " << (**i).getName() << " initialized." << "\n");
    }
  }

  // block renaming (A) was here

  Function *Main = M.getFunction("main");
  if (Main == 0) {
    errs() << "No main function detected. Qutting!";
    return false;
  } else {
    // Initialize the main function.
    if (PROF_OUTFILE || PROF_HIST || PROF_EVC) {
      insertModuleInitCall(Main, Blocks, M);
      DEBUG(errs() << "Module's main function initialized." << "\n");
    }
  }

  // Insert sampling call into each basic block.
  // TODO: What point in the basic block to insert? Easiest is end.
  initSampleProto(M.getContext());
  for (unsigned i = 0; i < Blocks.size(); ++i) {

    // MARTHA: blocks were already renamed above, so no need
    // also, want to instrument only the BBs that were in 
    // the program *before* any instrumentation added
    // 
    //   // Give our block our own name
    //   std::stringstream ss;
    //   ss << i;
    //   Blocks[i]->setName(std::string("bbl") + ss.str());
    // 

    if (PROF_HIST || PROF_EVC) {
      insertSampleCall(Blocks[i], i, M);
      DEBUG(errs() << "Basic block #" << i << " with name " << Blocks[i]->getName() << " has sampling call." << "\n");
    }
  }
  return true;
}

